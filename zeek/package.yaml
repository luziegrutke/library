id: zeek
name: Zeek Integration
author: Tenzir

description: |
  The Zeek package makes it easy to onboard Zeek logs in various ways and
  provides pipelines that map the logs to OCSF.

inputs:
  listen-endpoint:
    name: Listen Endpoint
    description: A TCP endpoint where Zeek sends its logs
    type: string
    default: 127.0.0.1:5555
  log-directory:
    name: Log Directory
    description: The local filesystem path where Zeek writes its logs
    type: string
    default: /opt/zeek/spool
  log-format:
    name: Log Format
    description: The log format that is configured in your Zeek deployment
    type: string
    default: zeek-json

pipelines:
  onboard-from-interface:
    name: Onboard Zeek Logs via TCP
    description: Connects a Zeek data source on the network.
    definition: |
      from tcp://{{ inputs.listen-endpoint }} read {{ inputs.log-format }}
      | publish zeek
    disabled: false

  onboard-from-file:
    name: Onboard Zeek via local log files
    description: Reads Zeek logs from the local filesystem.
    definition: |
        // TODO: implement the directory loader. This pipeline illustrates
        // currently how we'd want to have it written in TQL.
        load directory {{ inputs.log-directory }}
        | read {{ inputs.log-format }}
        | publish zeek
    disabled: true

  map-conn-to-ocsf:
    name: conn.log to OCSF Network Activity
    description: Maps Zeek connection logs to OCSF Network Activity.
    definition: |
      // tql2
      subscribe "zeek"
      where @name == "zeek.conn"
      if local_orig == true and local_resp == true {
        set direction = "Lateral", direction_id = 3
      } else if local_orig == true {
        set direction = "Outbound", direction_id = 2
      } else if local_resp == true {
        set direction = "Inbound", direction_id = 1
      } else {
        set direction = "Unknown", direction_id = 0
      }
      if proto == "tcp" {
        set protocol_num = 6
      } else if proto == "udp" {
        set protocol_num = 17
      } else if proto == "icmp" {
        set protocol_num = 1
      } else {
        set protocol_num = -1
      }
      if id.orig_h.is_v6() or id.resp_h.is_v6() {
        protocol_ver_id = 6
      } else {
        protocol_ver_id = 4
      }
      set class_uid = 4001, activity_id = 6, activity_name = "Traffic"
      set this = {
        // ----------------------
        // Base Event (Required)
        // ----------------------
        activity_id: activity_id,
        category_uid: 4,
        class_uid: class_uid,
        metadata: {
          log_name: "conn", // Zeek calls it "path"
          logged_time: _write_ts,
          product: {
            name: "Zeek",
            vendor_name: "Zeek",
          },
          uid: uid,
          version: "1.3.0",
        },
        time: ts,
        type_id: class_uid * 100 + activity_id,
        severity_id: 1,
        // -------------------------
        // Base Event (Recommended)
        // -------------------------
        // TODO: we actually could go deeper into the `conn_state` field and
        // choose a more accurate status. But this would require string
        // manipulations and/or regex matching, which TQL doesn't have yet.
        status: "Other",
        status_code: conn_state,
        status_id: 99,
        // ----------------------
        // Base Event (Optional)
        // ----------------------
        activity_name: activity_name,
        category_name: "Network Activity",
        class_name: "Network Activity",
        duration: duration,
        end_time: ts + duration,
        start_time: ts,
        severity: "Informational",
        // TODO: provide a function for this and make it possible to reference
        // `type_id` from the same assignment.
        //type_name: ocsf_type_name(type_id)
        unmapped: {
          history: history,
          missed_bytes: missed_bytes,
          orig_ip_bytes: orig_ip_bytes,
          resp_ip_bytes: resp_ip_bytes,
          // TODO: should we map these to `intermediate_ips` in Network
          // Endpoint?
          tunnel_parents: tunnel_parents,
        },
        // -----------------------
        // Event Class (Required)
        // -----------------------
        dst_endpoint: {
          ip: id.resp_h,
          port: id.resp_p,
          // TODO: start a conversation in the OCSF Slack to figure out how to
          // assign the entire connection a protocol. We use svc_name as the
          // next best thing, but it clearly can't be different between
          // endpoints for the service semantics that Zeek has.
          svc_name: service,
        },
        // -------------------------
        // Event Class (Recommended)
        // --------------------------
        connection_info: {
          uid: community_id,
          direction: direction,
          direction_id: direction_id,
          protocol_ver_id: protocol_ver_id,
          protocol_name: proto,
          protocol_num: protocol_num,
        },
        src_endpoint: {
          ip: id.orig_h,
          port: id.orig_p,
          svc_name: service,
        },
        traffic: {
          bytes_in: resp_bytes,
          bytes_out: orig_bytes,
          packets_in: resp_pkts,
          packets_out: orig_pkts,
          total_bytes: orig_bytes + resp_bytes,
          total_packets: orig_pkts + resp_pkts,
        },
        // -----------------------
        // Event Class (Optional)
        // -----------------------
        // TODO
        // - `ja4_fingerprint_list`: once we have some sample logs with JA4
        //   fingerprints, we should populate them here.
        // - `tls`: if we buffer ssl log for this connection, we could add the
        //    information in here.
      }
      publish "zeek.conn"
    disabled: false

  map-dns-to-ocsf:
    name: dns.log to OCSF DNS Activity
    description: Maps Zeek DNS logs to OCSF DNS Activity.
    definition: |
      // tql2
      subscribe "zeek"
      where @name == "zeek.dns"
      set class_uid = 4003, activity_id = 6, activity_name = "Traffic"
      if proto == "tcp" {
        set protocol_num = 6
      } else if proto == "udp" {
        set protocol_num = 17
      } else if proto == "icmp" {
        set protocol_num = 1
      } else {
        set protocol_num = -1
      }
      if id.orig_h.is_v6() or id.resp_h.is_v6() {
        protocol_ver_id = 6
      } else {
        protocol_ver_id = 4
      }
      set this = {
        // ----------------------
        // Base Event (Required)
        // ----------------------
        activity_id: activity_id,
        category_uid: 4,
        class_uid: class_uid,
        metadata: {
          log_name: "dns", // Zeek calls it "path"
          logged_time: _write_ts,
          product: {
            name: "Zeek",
            vendor_name: "Zeek",
          },
          uid: uid,
          version: "1.3.0",
        },
        time: ts,
        type_id: class_uid * 100 + activity_id,
        severity_id: 1,
        // -------------------------
        // Base Event (Recommended)
        // -------------------------
        status: "Other",
        status_id: 99,
        // ----------------------
        // Base Event (Optional)
        // ----------------------
        activity_name: activity_name,
        category_name: "Network Activity",
        class_name: "DNS Activity",
        start_time: ts,
        severity: "Informational",
        unmapped: {
          AA: AA,
          TC: TC,
          RD: RD,
          RA: RA,
          Z: Z,
          qclass: qclass,
          qtype: qtype,
          rtt: rtt,
          rejected: rejected,
          trans_id: trans_id,
        },
        // -----------------------
        // Event Class (Required)
        // -----------------------
        // -------------------------
        // Event Class (Recommended)
        // --------------------------
        query: {
          class: qclass_name,
          hostname: query,
          // TODO: go deeper and extract the log semantics.
          //opcode_id: 0,
          type: qtype_name,
        },
        // TODO: TQL needs native array handling for this to work. See the
        // Python below for a workaround.
        //answers: [..],
        connection_info: {
          direction: "Other",
          direction_id: 99,
          protocol_ver_id: protocol_ver_id,
          protocol_name: proto,
          protocol_num: protocol_num,
        },
        dst_endpoint: {
          ip: id.resp_h,
          port: id.resp_p,
        },
        src_endpoint: {
          ip: id.orig_h,
          port: id.orig_p,
        },
        query_time: ts,
        rcode: rcode_name,
        rcode_id: rcode,
        response_time: ts,
      }
      python "
        xs = [{'rdata': a, 'ttl': t} for a, t in zip(self.answers, self.TTLs)]
        self.answers = xs
      "
      publish "zeek.dns"
    disabled: false

  map-http-to-ocsf:
    name: http.log to OCSF HTTP Activity
    description: Maps Zeek HTTP logs to OCSF HTTP Activity.
    definition: |
      // tql2
      subscribe "zeek"
      where @name == "zeek.http"
      set class_uid = 4002, activity_name = method
      if method == "CONNECT" {
        activity_id = 1
      } else if method == "DELETE" {
        activity_id = 2
      } else if method == "GET" {
        activity_id = 3
      } else if method == "HEAD" {
        activity_id = 4
      } else if method == "OPTIONS" {
        activity_id = 5
      } else if method == "POST" {
        activity_id = 6
      } else if method == "PUT" {
        activity_id = 7
      } else if method == "TRACE" {
        activity_id = 8
      } else {
        activity_id = 0
      }
      if id.orig_h.is_v6() or id.resp_h.is_v6() {
        protocol_ver_id = 6
      } else {
        protocol_ver_id = 4
      }
      set this = {
        // ----------------------
        // Base Event (Required)
        // ----------------------
        activity_id: activity_id,
        category_uid: 4,
        class_uid: class_uid,
        metadata: {
          log_name: "http", // Zeek calls it "path"
          logged_time: _write_ts,
          product: {
            name: "Zeek",
            vendor_name: "Zeek",
          },
          uid: uid,
          version: "1.3.0",
        },
        time: ts,
        type_id: class_uid * 100 + activity_id,
        severity_id: 1,
        // -------------------------
        // Base Event (Recommended)
        // -------------------------
        status: "Other",
        status_id: 99,
        // ----------------------
        // Base Event (Optional)
        // ----------------------
        activity_name: activity_name,
        category_name: "Network Activity",
        class_name: "HTTP Activity",
        start_time: ts,
        severity: "Informational",
        unmapped: {
          trans_depth: trans_depth,
          request_body_len: request_body_len,
          response_body_len: response_body_len,
          info_code: info_code,
          info_msg: info_msg,
          tags: tags,
          username: username,
          password: password,
          // TODO: extract the value of X-FORWARDED-FOR and assign it to the
          // `x_forwarded_for` field.
          proxied: proxied,
          orig_fuids: orig_fuids,
          orig_filenames: orig_filenames,
          orig_mime_types: orig_mime_types,
          resp_fuids: resp_fuids,
          resp_filenames: resp_filenames,
          resp_mime_types: resp_mime_types,
        },
        // -----------------------
        // Event Class (Required)
        // -----------------------
        dst_endpoint: {
          ip: id.resp_h,
          port: id.resp_p,
        },
        http_request: {
           http_method: method,
           referrer: referrer,
           url: {
             hostname: host,
             // FIXME: Zeek's uri field is actually the path plus all
             // parameters. We just map this temporarily to path until we have
             // better string manipulation functions in TQL, e.g., splitting.
             path: uri,
           },
           user_agent: user_agent,
           version: version,
        },
        http_response: {
          code: status_code,
          status: status_msg,
        },
        // -------------------------
        // Event Class (Recommended)
        // --------------------------
        connection_info: {
          direction: "Other",
          direction_id: 99,
          protocol_ver_id: protocol_ver_id,
          protocol_name: "tcp",
          protocol_num: 6,
        },
        src_endpoint: {
          ip: id.orig_h,
          port: id.orig_p,
        },
      }
      publish "zeek.http"
    disabled: false

snippets:
  - name: Zeek log volume from the last 3 hours
    description: |
      A line chart displaying how many Zeek events arrived in the last 3 hours.
    definition: |
        // tql2
        metrics
        | where timestamp > 3 hour ago
        | where #schema == "tenzir.metrics.operator"
        | where pipeline_id == "zeek/onboard-from-interface"
                || pipeline_id == "zeek/onboard-from-file"
        | where source == true
        | summarize elements=sum(output.elements),
            approx_bytes=sum(output.approx_bytes),
            duration=sum(duration) by timestamp resolution 2 min
        | python '
          self.elements /= self.duration.total_seconds()
          self.approx_bytes /= self.duration.total_seconds()
        '
        | sort timestamp
        | legacy "chart area -x timestamp -y elements"
