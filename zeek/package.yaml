id: zeek
name: Zeek
author: Tenzir
author_icon: https://github.com/tenzir.png
package_icon: https://github.com/zeek.png

description: |
  The Zeek package makes it easy to onboard Zeek logs in various ways and
  provides pipelines that map the logs to OCSF.

inputs:
  listen-endpoint:
    name: Listen Endpoint
    description: A TCP endpoint where Zeek sends its logs
    type: string
    default: 127.0.0.1:5555
  log-directory:
    name: Log Directory
    description: The local filesystem path where Zeek writes its logs
    type: string
    default: /opt/zeek/spool
  log-format:
    name: Log Format
    description: The log format that is configured in your Zeek deployment
    type: string
    default: zeek-json

pipelines:
  onboard-from-interface:
    name: Onboard Zeek Logs via TCP
    description: Connects a Zeek data source on the network.
    definition: |
      from tcp://{{ inputs.listen-endpoint }} read {{ inputs.log-format }}
      | publish zeek

  onboard-from-file:
    name: Onboard Zeek via single file
    description: Reads Zeek logs from the local filesystem.
    definition: |
        // TODO: implement the directory loader. This pipeline illustrates
        // currently how we'd want to have it written in TQL.
        load directory {{ inputs.log-directory }}
        | read {{ inputs.log-format }}
        | publish zeek
    disabled: true

  map-conn-to-ocsf:
    name: conn.log to OCSF Network Activity
    description: Maps Zeek connection logs to OCSF Network Activity.
    definition: |
      // tql2
      subscribe "zeek"
      where @name == "zeek.conn"
      this = { event: this }
      class_uid = 4001
      activity_id = 6
      activity_name = "Traffic"
      if event.local_orig and event.local_resp {
        direction = "Lateral"
        direction_id = 3
      } else if event.local_orig {
        direction = "Outbound"
        direction_id = 2
      } else if event.local_resp {
        direction = "Inbound"
        direction_id = 1
      } else {
        direction = "Unknown"
        direction_id = 0
      }
      if event.proto == "tcp" {
        protocol_num = 6
      } else if event.proto == "udp" {
        protocol_num = 17
      } else if event.proto == "icmp" {
        protocol_num = 1
      } else {
        protocol_num = -1
      }
      if event.id.orig_h.is_v6() or event.id.resp_h.is_v6() {
        protocol_ver_id = 6
      } else {
        protocol_ver_id = 4
      }
      this = {
        // --- Classification (required) ---
        activity_id: activity_id,
        category_uid: 4,
        class_uid: class_uid,
        type_id: class_uid * 100 + activity_id,
        severity_id: 1,
        // --- Classification (optional) ---
        activity_name: activity_name,
        category_name: "Network Activity",
        class_name: "Network Activity",
        severity: "Informational",
        // TODO: provide a function for this and make it possible to reference
        // `type_id` from the same assignment.
        //type_name: ocsf_type_name(type_id),
        // --- Occurrence (required) ---
        time: event.ts,
        // --- Occurrence (recommended) ---
        // TODO: provide a function for this
        //timezone_offset: ..
        // --- Occurrence (optional) ---
        duration: event.duration,
        end_time: event.ts + event.duration,
        start_time: event.ts,
        // --- Context (required) ---
        metadata: {
          log_name: "conn", // Zeek calls it "path"
          logged_time: event._write_ts,
          product: {
            name: "Zeek",
            vendor_name: "Zeek",
          },
          uid: event.uid,
          version: "1.3.0",
        },
        // --- Context (optional) ---
        unmapped: event,
        // --- Primary (required) ---
        dst_endpoint: {
          ip: event.id.resp_h,
          port: event.id.resp_p,
          // TODO: start a conversation in the OCSF Slack to figure out how to
          // assign the entire connection a protocol. We use svc_name as the
          // next best thing, but it clearly can't be different between
          // endpoints for the service semantics that Zeek has.
          svc_name: event.service,
        },
        // --- Primary (recommended) ---
        connection_info: {
          uid: event.community_id,
          direction: direction,
          direction_id: direction_id,
          protocol_ver_id: protocol_ver_id,
          protocol_name: event.proto,
          protocol_num: protocol_num,
        },
        src_endpoint: {
          ip: event.id.orig_h,
          port: event.id.orig_p,
          svc_name: event.service,
        },
        // TODO: we actually could go deeper into the `conn_state` field and
        // choose a more accurate status. But this would require string
        // manipulations and/or regex matching, which TQL doesn't have yet.
        status: "Other",
        status_code: event.conn_state,
        status_id: 99,
        traffic: {
          bytes_in: event.resp_bytes,
          bytes_out: event.orig_bytes,
          packets_in: event.resp_pkts,
          packets_out: event.orig_pkts,
          total_bytes: event.orig_bytes + event.resp_bytes,
          total_packets: event.orig_pkts + event.resp_pkts,
        },
        // --- Primary (optional) ---
        // TODO
        // - `ja4_fingerprint_list`: once we have some sample logs with JA4
        //   fingerprints, which requires an additional Zeek package, we should
        //   populate them here.
        // - `tls`: if we buffer ssl log for this connection, we could add the
        //   information in here.
      }
      // Drop all the mapped fields.
      drop (
        unmapped._write_ts,
        unmapped.community_id,
        unmapped.conn_state,
        unmapped.duration,
        unmapped.id,
        unmapped.local_orig,
        unmapped.local_resp,
        unmapped.orig_bytes,
        unmapped.orig_pkts,
        unmapped.proto,
        unmapped.resp_bytes,
        unmapped.resp_pkts,
        unmapped.service,
        unmapped.ts,
        unmapped.uid,
      )
      @name = "ocsf.network_activity"
      publish "ocsf.network_activity"

  map-dns-to-ocsf:
    name: dns.log to OCSF DNS Activity
    description: Maps Zeek DNS logs to OCSF DNS Activity.
    definition: |
      // tql2
      subscribe "zeek"
      where @name == "zeek.dns"
      this = { event: this }
      class_uid = 4003
      activity_id = 6
      activity_name = "Traffic"
      if event.proto == "tcp" {
        protocol_num = 6
      } else if event.proto == "udp" {
        protocol_num = 17
      } else if event.proto == "icmp" {
        protocol_num = 1
      } else {
        protocol_num = -1
      }
      if event.id.orig_h.is_v6() or event.id.resp_h.is_v6() {
        protocol_ver_id = 6
      } else {
        protocol_ver_id = 4
      }
      this = {
        // --- Classification (required) ---
        activity_id: activity_id,
        category_uid: 4,
        class_uid: class_uid,
        type_id: class_uid * 100 + activity_id,
        severity_id: 1,
        // --- Classification (optional) ---
        activity_name: activity_name,
        category_name: "Network Activity",
        class_name: "DNS Activity",
        severity: "Informational",
        // TODO: provide a function for this and make it possible to reference
        // `type_id` from the same assignment.
        //type_name: ocsf_type_name(type_id),
        // --- Occurrence (required) ---
        time: event.ts,
        // --- Occurrence (recommended) ---
        // TODO: provide a function for this
        //timezone_offset: ..
        // --- Occurrence (optional) ---
        start_time: event.ts,
        // --- Context (required) ---
        metadata: {
          log_name: "dns", // Zeek calls it "path"
          logged_time: event._write_ts,
          product: {
            name: "Zeek",
            vendor_name: "Zeek",
          },
          uid: event.uid,
          version: "1.3.0",
        },
        // --- Context (optional) ---
        unmapped: event,
        // --- Primary (recommended) ---
        query: {
          class: event.qclass_name,
          hostname: event.query,
          // TODO: go deeper and extract the log semantics.
          //opcode_id: 0,
          type: event.qtype_name,
        },
        connection_info: {
          direction: "Other",
          direction_id: 99,
          protocol_ver_id: protocol_ver_id,
          protocol_name: event.proto,
          protocol_num: protocol_num,
        },
        dst_endpoint: {
          ip: event.id.resp_h,
          port: event.id.resp_p,
        },
        src_endpoint: {
          ip: event.id.orig_h,
          port: event.id.orig_p,
        },
        query_time: event.ts,
        rcode: event.rcode_name,
        rcode_id: event.rcode,
        response_time: event.ts,
        status: "Other",
        status_id: 99,
      }
      //python "
      //  xs = [{'rdata': a, 'ttl': t} for a, t in zip(self.event.answers, self.event.TTLs)]
      //  self.answers = xs
      //"
      // Drop all the mapped fields.
      drop (
        unmapped._write_ts,
        unmapped.answers,
        unmapped.id,
        unmapped.proto,
        unmapped.qclass_name,
        unmapped.qtype_name,
        unmapped.query,
        unmapped.rcode_name,
        unmapped.rcode,
        unmapped.ts,
        unmapped.uid,
        unmapped.TTLs,
      )
      @name = "ocsf.dns_activity"
      publish "ocsf.dns_activity"

  map-http-to-ocsf:
    name: http.log to OCSF HTTP Activity
    description: Maps Zeek HTTP logs to OCSF HTTP Activity.
    definition: |
      // tql2
      subscribe "zeek"
      where @name == "zeek.http"
      this = { event: this }
      class_uid = 4002
      activity_name = event.method
      if event.method == "CONNECT" {
        activity_id = 1
      } else if event.method == "DELETE" {
        activity_id = 2
      } else if event.method == "GET" {
        activity_id = 3
      } else if event.method == "HEAD" {
        activity_id = 4
      } else if event.method == "OPTIONS" {
        activity_id = 5
      } else if event.method == "POST" {
        activity_id = 6
      } else if event.method == "PUT" {
        activity_id = 7
      } else if event.method == "TRACE" {
        activity_id = 8
      } else {
        activity_id = 0
      }
      if event.id.orig_h.is_v6() or event.id.resp_h.is_v6() {
        protocol_ver_id = 6
      } else {
        protocol_ver_id = 4
      }
      this = {
        // --- Classification (required) ---
        activity_id: activity_id,
        category_uid: 4,
        class_uid: class_uid,
        type_id: class_uid * 100 + activity_id,
        severity_id: 1,
        // --- Classification (optional) ---
        activity_name: activity_name,
        category_name: "Network Activity",
        class_name: "HTTP Activity",
        severity: "Informational",
        // TODO: provide a function for this and make it possible to reference
        // `type_id` from the same assignment.
        //type_name: ocsf_type_name(type_id),
        // --- Occurrence (required) ---
        time: event.ts,
        // --- Occurrence (optional) ---
        start_time: event.ts,
        // --- Context (required) ---
        metadata: {
          log_name: "http", // Zeek calls it "path"
          logged_time: event._write_ts,
          product: {
            name: "Zeek",
            vendor_name: "Zeek",
          },
          uid: event.uid,
          version: "1.3.0",
        },
        // --- Context (optional) ---
        unmapped: event,
        // --- Primary (required) ---
        dst_endpoint: {
          ip: event.id.resp_h,
          port: event.id.resp_p,
        },
        http_request: {
           http_method: event.method,
           referrer: event.referrer,
           url: {
             hostname: event.host,
             // FIXME: Zeek's uri field is actually the path plus all
             // parameters. We just map this temporarily to path until we have
             // better string manipulation functions in TQL, e.g., splitting.
             path: event.uri,
           },
           user_agent: event.user_agent,
           version: event.version,
        },
        http_response: {
          code: event.status_code,
          status: event.status_msg,
        },
        // --- Primary (recommended) ---
        connection_info: {
          direction: "Other",
          direction_id: 99,
          protocol_ver_id: protocol_ver_id,
          protocol_name: "tcp",
          protocol_num: 6,
        },
        src_endpoint: {
          ip: event.id.orig_h,
          port: event.id.orig_p,
        },
        status: "Other",
        status_id: 99,
      }
      // Drop all the mapped fields.
      drop (
        unmapped.method,
        unmapped.id,
        unmapped.ts,
        unmapped._write_ts,
        unmapped.uid,
        unmapped.referrer,
        unmapped.host,
        unmapped.uri,
        unmapped.user_agent,
        unmapped.version,
        unmapped.status_code,
        unmapped.status_msg,
      )
      @name = "ocsf.http_activity"
      publish "ocsf.http_activity"

snippets:
  - name: Zeek log volume from the last 3 hours
    description: |
      A line chart displaying how many Zeek events arrived in the last 3 hours.
    definition: |
        // tql2
        metrics
        | where timestamp > 3 hour ago
        | where #schema == "tenzir.metrics.operator"
        | where pipeline_id == "zeek/onboard-from-interface"
                || pipeline_id == "zeek/onboard-from-file"
        | where source == true
        | summarize elements=sum(output.elements),
            approx_bytes=sum(output.approx_bytes),
            duration=sum(duration) by timestamp resolution 2 min
        | python '
          self.elements /= self.duration.total_seconds()
          self.approx_bytes /= self.duration.total_seconds()
        '
        | sort timestamp
        | legacy "chart area -x timestamp -y elements"
